Viktor Jankov
Senior Capstone Project

Describe in detail your capstone experience (at least one page): 

For my capstone project I did a software development internship at Asynchrony. Asynchrony is a mobile and application development company based out of St. Louis which also does Agile consulting for companies in the Midwest. Some of their past customers were Monsanto, the Departments of Defense, Deloitte, Mastercard and others. 

The internship project consisted of converting an Agile board game into a mobile application. There were thirteen interns, six working on an Android version, six on iOS version and one designer. Each team also had one tech lead whose role consisted of creating and refining user stories as well as providing general mentorship and good advice throughout the internship. We also had an internship coordinator whose role was the equivalent of a business analyst, and finally a customer, which in our case was the CTO of the company. The goal of the internship was to not only learn how to develop Android applications, but also to develop good software development practices that will make us better developers even after the internship is over. Their goal was not to make us expert Android or iOS developers in three months, but to teach us good habits so that no matter what technology we might be working with, we would follow good practices and make our code extensible, reusable, maintainable and testable. 

My role was working on the Android team and making the Androird version of the game. Unfortunatelly during my first week one person on our team left, so until the end of the summer our tech lead paired up with one of us and was more involved in the implementation process than the tech lead of the iOS team. 

Typical Day
On a typical day we would come in at around 9:00pm and have a stand-up at 9:30 that would last no more than three minutes. After that, we would pair with another person and pull the right-most story from the Kanban board. Some of the time this would be a user story not yet started, but other times this was a bug found by QA or a story that was started the prior day but was not yet finished. I would work with the first person until 11:00pm after which we had a pair switch. The second pairing of the day usually lasted until 2:30pm with an hour off during lunch. At 2:30 we would have another stand-up meeting after which we would have our third and final pair switch for the day. We would wrap up our work around 5-5:30, and push the latest work we've done to the remote repository. 


Agile Practices
Asynchrony prides itself on being an Agile company, so they tried to incorporate as much as possible of good Agile practices into the internship experience. Here I'll name few things that we did on a daily basis, which shows that they are really serious about Agile, and really wanted to teach us those practices so that we may use them and write better code.

First, there was huge focus on pair-programming. You couldn't write any production code unless there was another person paired with you. No one had their personal workstations, instead everyone shared the same computers and could log into any development station in the company. Everywhere you went you could hear chatter and collaboration from people working together to hash out a design or implement a story.

Another core value that we practiced daily was TDD (Test-Driven Development). This was by far one of the most challenging things to learn and it took us half of the internship to get to a place where we felt comfortable with TDD (not be good at it, but just feel comfortable doing it). The urge to just start writing code is very strong (because it's so much fun) but it's only after the fact do you see the benefits of having tests around your code and not having to worry about introducing bugs when refactoring. Pair programming helps because people hold each other accountable and it prevents against spikes gone awry. 

We also kept a CI (Continious Integration) build at all times, which was essentially a server that had the latest version of the application. The idea was that the customer could walk in anythem they wanted to and they could see the progress on the application. 

Each Friday we gave a presentation to our customer, which for us was the CTO of the company. Each team presented the progress they've made during the week and would show off the latest features implemented. We also had weekly "retrospectives" where we discussed issues and came up with solutions on how to fix them. The goal of the retrospectives was to produce "actionable" items so that next week we could say we either fixed the issue or we didn't.

Last but not least, we used user stories to implement the features of the application. We created these during a bi-weekly meeting in which we listed the acceptance criteria (used by QA to test the new functionality) and voted on story size. The stories were put on a Kanban board with several columns: Backlog (where all new user stories went), Work in Progress, Code Review, QA Review, Bugs and QA Pass. The stories in QA pass were merged into the main apk (aplication package) and this is what we presented to the customer. One process that we introduced, which I really liked, was "new story turn around". The pair that starts a new story would do a quick turnaround to let everyone know that they are pulling a new story and to describe some of the acceptance criteria of the story. This was really beneficial because as the code base started growing bigger, we could identify the necessary classes and methods to do the work. This lead to greater knowledge sharing and implementing stories faster because we didn't have to re-invent the wheel every time. 

Tools
We used plenty of tools throughout the internship. One of the biggest challenges was learning how these tools worked and how to use them appropriately. In the beginning we even had to strip down some libraries we used because it was too overwhelming. 

First we used Git for version control. Our branch management was as follows: we had a main development branch that we developed on. Each pair would start their story on a branch called "bug #" and branch off dev. When done with the story they would submit a merge request, after which a team will do a code review, allow or failing the request and merge the branch into dev. QA would then use the dev branch to test the new features and if everything passed, dev would be merged into a master branch at the end of the week. 

Next, to help with TDD we had to rely on JUnit and bunch of other frameworks such as Mockito for mocking out objects, RoboGuice for injection and dependency inversion, Robotium and MonkeyRunner for UI testing and Robolectric for testing the Android parts of our code (Views, Lifecycle events etc.)
We also used several other libraries that helped with abstracting out details of Android that we didn't care about. They generated some of the boilerplate code for us, so that we could only focus on the business logic. Some libraries included Otto, AndroidAnnotations, Jackson, StaggeredGridView, and Gradle.

Hardware wise we  we used mini Mac to begin with, but because Android is really resource heavy we had to switch to using Ubuntu mid-way through the internship. Because we used Git, this was super easy and took us maybe 30 minutes to switch machines and go back to our regular workflow. 

Learning Challenges
I think by far the hardest challenge I faced was learning how to do proper TDD. TDD is unlike anything I've encountered before and it takes a while to learn how to think in the TDD ways. The urge to just write code is too strong and you have to actively go against your natural instincts, but I think it's worth it. We realized the advantages of TDD whenever we had to refactor or make design changes. I felt much more comfortable changing our code because I instanly knew if any of my changes introduced a new bug or not. Because with TDD testing becomes the focus, and not just an afterhtought, code coverage is higher and tests have higher quality. 
On top of learning to think in TDD terms, we also had to learn the tools that help you with TDD such as mocks and injections, which I had never encountered before this internship. Mocking out is essential for unit testing and it takes some time to learn the APIs available. 

Another challenge I encountered was learning Git for the first time, though I think it's very intuitive way to think about version control and it didn't take very long to get comfortable with it. After you learn Git though, you realize that the benefits of using it are enormous, and it's hard to understand why wouldn't you use it for everything. I've started using it for anything, from programs assignments to writing papers and my resume. It's really an awesome tool that helps you so much, and it's pretty easy to learn it too. 

Problem I encountered and it's solution
One particular problem that I faced was changing the code of an existing library to adopt it to our application's needs. 
The story was to implement a Grid Layout from several blocks available on the screen, but according to the design specifications it had to staggered grid, because some blocks where taller than others, so they all had to stack on top of another. The library that we used to help us with this, supported staggered grid but the blocks were meant to be static, they couldn't change size. The problem was that in our game, whenever the player finished a card, the card would collapse to a much smaller rectangle, and all other cards on top and bottom were supposed to wrap around it. To incorporate this piece into our application required that we really looked deeper into the library we were using and really understand the APIs available. Eventually, I fixed this bug by calling several methods consecutively, essentially emulating a destruction of the old and re-creation of a new staggered grid view with the new data. I was really proud because it was essential to our app's design to have staggered grid view, but also because our tech lead tried fixing this issue before and couldn't get it to work. It was realization that to be a good software engineer you need experience, but there is also that "aha" factor that comes from getting an insight into a problem. It's not necessary to know every API method available, but as long as you can think logically about an issue and try to really understand it, you can solve pretty much anything thrown at you. 

CS Courses that were useful
Courses that were really useful were CS 181 and CS260 because Android is in Java and is extremely object oriented. You really need to be strong in this area to fully take advantage of the power and flexibility of OOP in general and Android in particular. Code using polymorphism, abstraction, inheritance, encapsulation, anonymous classes, event Listeners are all over Android and you really need to master these topics in order to write extensible and maintainable code. 

Another very useful class was CS315 - Internet Programming. There we were exposed to some of the basic design terminology that every developer should know what they are (margin, padding, font size etc.) It was essential to understand these so that we could code up the design specified by the designers and get it as close as possible to their mocks. 

Finally, Software Engineering exposed me to Git and some of the ideas behind Agile. Everything we learned in class was spot on, and it was really interesting to see how we were applying some of the things we learned about in class, on a day-to-day basis in the workplace. Also in Software Engineering I first learned how to use JUnit and how to write tests, which was very important because doing TDD, you're going to write hundreds of tests no matter what, and becoming comfortable with JUnit is essential.

Non-CS courses that were useful
	I don't know if there are any specific classes that were useful, but I do think that liberal arts education exposes us to more diverse topics and make us aware that there is an interesting world outside that doesn't really care about computers as much as we do. Taking those classes instilled in me a curiosity to learn more about the world in general and to appreciate the experiences that individual people bring to the team. I feel like I can always learn something new no matter whom I talk to. I think liberal arts classes have made me a more rounded individual, and I can interact with people from many diverse backgrounds because of it. I can always find something in common with another person and form a friendship around it.

Positives 
	I think this is one of the best internship that CS students at Truman can do. Because it was a development internship, I wrote tons of code and I learned a lot as a result. Writing code daily really helped me develop my Java skills and learn programming on a deeper level. Whereas in college we get exposed to many topics and know a little bit about many things, here we were exposed to one topic but had a chance to really understand it and get good at it. 

	Also I was really lucky because our Tech Lead really cared about good code, held us to a very high standards and was not afraid to code review fail us for bad code. He was very pro-active in working with us, showing us good patterns and helping us overcome the bad ones. He was also really patient and I think we on the Android team learned so much more than the iOS team because we had such a pro-active Tech Lead.

	More practically, I also learned some cutting edge technologies that helped me become a better developer and write better code. Learning TDD, using Git, writing OO code, working in an Agile team doing pair programming, these are all cutting edge practices that the earlier I learn them the more value I get out of them, because that's where in industry is moving. 

Negatives
	Not everything was rosy though, and I also found few places for improvement or where I didn't necessarily agree with how Asynchrony did things. I don't like to follow TDD religiously, but I want it in a more flexible flavor. There were few times where we had to change our design and expose more data than we should've just so that we could test the classes. Our final design ended up being more rigid which kind of defeats the purpose of TDD and there were cases where I would've been fine without white-box testing a class if it gave us a better design and cleaner code. 

	Another practice where I'm skeptical is pair programming. I see it as a double edged sword. If two people are paired and they have roughly the same skill level, then pair programming is awesome and it does marvels. But if one person is much weaker than the other, than there really is no pair programming and it becomes one person teaching the other how to do stuff. This slows down development and it's wasting resources. So I'd be very careful if I had to choose pair programming for a team because finding good pairs is as much as art as is science and could backfire. 

Indicate if there is anything you now realize that you should have known or studied before starting your capstone experience
	One nice thing is that when you go into an internship, the company assumes that you don't know much, which in most cases is true. The company assumes you don't know much, but are able to learn new things quickly and pick up new technologies. 

	But to be specific, I would've loved to be exposed to JUnit much earlier than Software Engineering. Writing test is inevitable no matter what kind of development you do, so ideally students would've been exposed to JUnit in CS181 and CS260 so that they at least know how to setup the test suite and write basic tests. 

	Also Git should be introduced in school, because if anything, it'll make life much easier and I'll never have to email code to myself ever again. Also I'll never again have to worry about accidently deleting my code and having to start from scratch again. 

Explain whether the experience turned out the way that you anticipated that it would
	Overall, this internship was a life changing experience, because if anything, it made me realize how much I enjoyed writing code. It was the first job where I was actually looking forward to going to work every day and was excited to start the day. I learned a lot, I made few good friends and I had tons of fun starting from scratch and building this application that would've been used by other people in the company. 

	But it's also thanks to this internship that I have a job going into my final semester. Because we did pair-programming every day, I have never been worried about a technical interview ever since. I just see it as another opportunity to solve an interesting puzzle with another person and I feel completely comfortable with writing code while someone's looking over my shoulder.


